#include <stdlib.h>      #include "seqList.h"template <class E>//构造函数SeqList<E>::SeqList(int sz) {	if (sz > 0) {		maxSize = sz;  last = -1;		data = new E[maxSize];	   //创建表存储数组		if (data == NULL) {   //动态分配失败			cerr << "存储分配错误！" << endl;			exit(1);		}	}};//拷贝构造函数template <class E>SeqList<E>::SeqList(SeqList<E>& L) {	maxSize = L.Size();   last = L.Length() - 1;  E value;	data = new E[maxSize];	//创建存储数组	if (data == NULL)		//动态分配失败	{		cerr << "存储分配错误！" << endl;     exit(1);	}	for (int i = 1; i <= last + 1; i++)    //传送各个表项	{		L.getData(i, value); data[i - 1] = value;	}};//搜索template <class E>int SeqList<E>::Search(E& x) const {	//在表中顺序搜索与给定值 x 匹配的表项，找到则	//函数返回该表项是第几个元素，否则函数返回0	for (int i = 0; i <= last; i++)	//顺序搜索		if (data[i] == x)            return i + 1; //表项序号和表项位置差1	return 0;		    //搜索失败};//插入template <class E>bool SeqList<E>::Insert(int i, E x) {	//将新元素x插入到表中第i (1≤i≤last+2) 个表项位	//置。	if (last == maxSize - 1) return false;        //表满	if (i < 1 || i > last + 2) return false;  //参数i不合理	for (int j = last; j >= i - 1; j--)                 //依次后移		data[j + 1] = data[j];	data[i - 1] = x;	      //插入(第 i 表项在data[i-1]处)	last++;    return true;		           //插入成功};//删除第i项并获得其值template <class E>bool SeqList<E>::Remove(int i, E& x) {	//从表中删除第 i (1≤i≤last+1) 个表项，通过引用型	//参数 x 返回被删元素。	if (last == -1) return false;	           //表空	if (i < 1 || i > last + 1) return false;//参数i不合理	x = data[i - 1];	for (int j = i; j <= last; j++)      //依次前移，填补		data[j - 1] = data[j];	last--;      return true;};//集合并运算void Union(SeqList<int>& LA,	SeqList<int>& LB) {	int n = LA.Length();	int m = LB.Length();	int x;	for (int i = 1; i <= m; i++) {		LB.getData(i, x);     //在LB中取一元素		int k = LA.Search(x);     //在LA中搜索它		if (k == 0)                //若未找到插入它		{			n++; LA.Insert(n, x);		}	}}//集合交运算void Intersection(SeqList<int>& LA,	SeqList<int>& LB) {	int n = LA.Length();	int m = LB.Length();  int i = 1; int x;	while (i <= n) {		LA.getData(i, x);    //在LA中取一元素		int k = LB.Search(x);      //在LB中搜索它			if (k == 0) { LA.Remove(i, x);  n--; }		//未找到,在LA中删除它		else i++;	}}